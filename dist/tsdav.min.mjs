import{fetch as e}from"cross-fetch";import t from"debug";import r from"xml-js";import{encode as a}from"base-64";var s;!function(e){e.CALENDAR_SERVER="http://calendarserver.org/ns/",e.CALDAV_APPLE="http://apple.com/ns/ical/",e.CALDAV="urn:ietf:params:xml:ns:caldav",e.CARDDAV="urn:ietf:params:xml:ns:carddav",e.DAV="DAV:"}(s||(s={}));const o={[s.CALDAV]:"xmlns:c",[s.CARDDAV]:"xmlns:card",[s.CALENDAR_SERVER]:"xmlns:cs",[s.CALDAV_APPLE]:"xmlns:ca",[s.DAV]:"xmlns:d"};var n,d;!function(e){e.CALDAV="c",e.CARDDAV="card",e.CALENDAR_SERVER="cs",e.CALDAV_APPLE="ca",e.DAV="d"}(n||(n={})),function(e){e.VEVENT="VEVENT",e.VTODO="VTODO",e.VJOURNAL="VJOURNAL",e.VFREEBUSY="VFREEBUSY",e.VTIMEZONE="VTIMEZONE",e.VALARM="VALARM"}(d||(d={}));const l=e=>{const t=Number(e);if(!Number.isNaN(t))return t;const r=e.toLowerCase();return"true"===r||"false"!==r&&e},c=(e,t)=>{if(!e&&!t)return!0;if(!e||!t)return!1;const r=e.trim(),a=t.trim();if(Math.abs(r.length-a.length)>1)return!1;const s="/"===r.slice(-1)?r.slice(0,-1):r,o="/"===a.slice(-1)?a.slice(0,-1):a;return e.includes(o)||t.includes(s)},i=(e,t)=>{if(!e&&!t)return!0;if(!e||!t)return!1;const r=e.trim(),a=t.trim(),s="/"===r.slice(-1)?r.slice(0,-1):r,o="/"===a.slice(-1)?a.slice(0,-1):a;return e.includes(o)||t.includes(s)},u=e=>e.reduce(((e,t)=>({...e,[o[t]]:t})),{}),h=e=>Object.entries(e).reduce(((e,[t,r])=>r?{...e,[t]:r}:e),{}),p=(e,t)=>t?{[e]:t}:{},v=(e,t)=>e?t&&0!==t.length?Object.fromEntries(Object.entries(e).filter((([e])=>!t.includes(e)))):e:{};var y=Object.freeze({__proto__:null,cleanupFalsy:h,conditionalParam:p,excludeHeaders:v,getDAVAttribute:u,urlContains:i,urlEquals:c});const f=t("tsdav:request"),m=async t=>{var a;const{url:s,init:o,convertIncoming:n=!0,parseOutgoing:d=!0}=t,{headers:c={},body:i,namespace:u,method:p,attributes:v}=o,y=n?r.js2xml({_declaration:{_attributes:{version:"1.0",encoding:"utf-8"}},...i,_attributes:v},{compact:!0,spaces:2,elementNameFn:e=>u&&!/^.+:.+/.test(e)?`${u}:${e}`:e}):i,m=await e(s,{headers:{"Content-Type":"text/xml;charset=UTF-8",...h(c)},body:y,method:p}),A=await m.text();if(!m.ok||!(null===(a=m.headers.get("content-type"))||void 0===a?void 0:a.includes("xml"))||!d)return[{href:m.url,ok:m.ok,status:m.status,statusText:m.statusText,raw:A}];const g=r.xml2js(A,{compact:!0,trim:!0,textFn:(e,t)=>{try{const r=t._parent,a=Object.keys(r),s=a[a.length-1],o=r[s];if(o.length>0){o[o.length-1]=l(e)}else r[s]=l(e)}catch(e){f(e.stack)}},elementNameFn:e=>e.replace(/^.+:/,"").replace(/([-_]\w)/g,(e=>e[1].toUpperCase())),attributesFn:e=>{const t={...e};return delete t.xmlns,t},ignoreDeclaration:!0});return(Array.isArray(g.multistatus.response)?g.multistatus.response:[g.multistatus.response]).map((e=>{var t,r;if(!e)return{status:m.status,statusText:m.statusText,ok:m.ok};const a=/^\S+\s(?<status>\d+)\s(?<statusText>.+)$/.exec(e.status);return{raw:g,href:e.href,status:(null==a?void 0:a.groups)?Number.parseInt(null==a?void 0:a.groups.status,10):m.status,statusText:null!==(r=null===(t=null==a?void 0:a.groups)||void 0===t?void 0:t.statusText)&&void 0!==r?r:m.statusText,ok:!e.error,error:e.error,responsedescription:e.responsedescription,props:(Array.isArray(e.propstat)?e.propstat:[e.propstat]).reduce(((e,t)=>({...e,...null==t?void 0:t.prop})),{})}}))},A=async e=>{const{url:t,props:r,depth:a,headers:o,headersToExclude:d}=e;return m({url:t,init:{method:"PROPFIND",headers:v(h({depth:a,...o}),d),namespace:n.DAV,body:{propfind:{_attributes:u([s.CALDAV,s.CALDAV_APPLE,s.CALENDAR_SERVER,s.CARDDAV,s.DAV]),prop:r}}}})},g=async t=>{const{url:r,data:a,headers:s,headersToExclude:o}=t;return e(r,{method:"PUT",body:a,headers:v(s,o)})},D=async t=>{const{url:r,data:a,etag:s,headers:o,headersToExclude:n}=t;return e(r,{method:"PUT",body:a,headers:v(h({"If-Match":s,...o}),n)})},C=async t=>{const{url:r,headers:a,etag:s,headersToExclude:o}=t;return e(r,{method:"DELETE",headers:v(h({"If-Match":s,...a}),o)})};var w=Object.freeze({__proto__:null,createObject:g,davRequest:m,deleteObject:C,propfind:A,updateObject:D});function b(e,t){const r=e=>t.every((t=>e[t]));return Array.isArray(e)?e.every((e=>r(e))):r(e)}const V=(e,t)=>t.reduce(((t,r)=>e[r]?t:`${t.length?`${t},`:""}${r.toString()}`),""),E=t("tsdav:collection"),T=async e=>{const{url:t,body:r,depth:a,defaultNamespace:s=n.DAV,headers:o,headersToExclude:d}=e,l=await m({url:t,init:{method:"REPORT",headers:v(h({depth:a,...o}),d),namespace:s,body:r}});return 1!==l.length||l[0].raw?l:[]},$=async e=>{const{url:t,props:r,depth:a,headers:s,headersToExclude:o}=e;return m({url:t,init:{method:"MKCOL",headers:v(h({depth:a,...s}),o),namespace:n.DAV,body:r?{mkcol:{set:{prop:r}}}:void 0}})},k=async e=>{var t,r,a,s,o;const{collection:d,headers:l,headersToExclude:c}=e;return null!==(o=null===(s=null===(a=null===(r=null===(t=(await A({url:d.url,props:{[`${n.DAV}:supported-report-set`]:{}},depth:"0",headers:v(l,c)}))[0])||void 0===t?void 0:t.props)||void 0===r?void 0:r.supportedReportSet)||void 0===a?void 0:a.supportedReport)||void 0===s?void 0:s.map((e=>Object.keys(e.report)[0])))&&void 0!==o?o:[]},U=async e=>{var t,r,a;const{collection:s,headers:o,headersToExclude:d}=e,l=(await A({url:s.url,props:{[`${n.CALENDAR_SERVER}:getctag`]:{}},depth:"0",headers:v(o,d)})).filter((e=>i(s.url,e.href)))[0];if(!l)throw new Error("Collection does not exist on server");return{isDirty:s.ctag!==(null===(t=l.props)||void 0===t?void 0:t.getctag),newCtag:null===(a=null===(r=l.props)||void 0===r?void 0:r.getctag)||void 0===a?void 0:a.toString()}},_=e=>{const{url:t,props:r,headers:a,syncLevel:o,syncToken:d,headersToExclude:l}=e;return m({url:t,init:{method:"REPORT",namespace:n.DAV,headers:v({...a},l),body:{"sync-collection":{_attributes:u([s.CALDAV,s.CARDDAV,s.DAV]),"sync-level":o,"sync-token":d,[`${n.DAV}:prop`]:r}}}})},O=async e=>{var t,r,a,s,o,d,l,c,u,h,p;const{collection:y,method:f,headers:m,headersToExclude:A,account:g,detailedResult:D}=e,C=["accountType","homeUrl"];if(!g||!b(g,C)){if(!g)throw new Error("no account for smartCollectionSync");throw new Error(`account must have ${V(g,C)} before smartCollectionSync`)}const w=null!=f?f:(null===(t=y.reports)||void 0===t?void 0:t.includes("syncCollection"))?"webdav":"basic";if(E(`smart collection sync with type ${g.accountType} and method ${w}`),"webdav"===w){const e=await _({url:y.url,props:{[`${n.DAV}:getetag`]:{},[`${"caldav"===g.accountType?n.CALDAV:n.CARDDAV}:${"caldav"===g.accountType?"calendar-data":"address-data"}`]:{},[`${n.DAV}:displayname`]:{}},syncLevel:1,syncToken:y.syncToken,headers:v(m,A)}),t=e.filter((e=>{var t;const r="caldav"===g.accountType?".ics":".vcf";return(null===(t=e.href)||void 0===t?void 0:t.slice(-4))===r})),u=t.filter((e=>404!==e.status)).map((e=>e.href)),h=t.filter((e=>404===e.status)).map((e=>e.href)),p=(u.length&&null!==(a=await(null===(r=null==y?void 0:y.objectMultiGet)||void 0===r?void 0:r.call(y,{url:y.url,props:{[`${n.DAV}:getetag`]:{},[`${"caldav"===g.accountType?n.CALDAV:n.CARDDAV}:${"caldav"===g.accountType?"calendar-data":"address-data"}`]:{}},objectUrls:u,depth:"1",headers:v(m,A)})))&&void 0!==a?a:[]).map((e=>{var t,r,a,s,o,n,d,l,c,i;return{url:null!==(t=e.href)&&void 0!==t?t:"",etag:null===(r=e.props)||void 0===r?void 0:r.getetag,data:"caldav"===(null==g?void 0:g.accountType)?null!==(o=null===(s=null===(a=e.props)||void 0===a?void 0:a.calendarData)||void 0===s?void 0:s._cdata)&&void 0!==o?o:null===(n=e.props)||void 0===n?void 0:n.calendarData:null!==(c=null===(l=null===(d=e.props)||void 0===d?void 0:d.addressData)||void 0===l?void 0:l._cdata)&&void 0!==c?c:null===(i=e.props)||void 0===i?void 0:i.addressData}})),f=null!==(s=y.objects)&&void 0!==s?s:[],C=p.filter((e=>f.every((t=>!i(t.url,e.url))))),w=f.reduce(((e,t)=>{const r=p.find((e=>i(e.url,t.url)));return r&&r.etag&&r.etag!==t.etag?[...e,r]:e}),[]),b=h.map((e=>({url:e,etag:""}))),V=f.filter((e=>p.some((t=>i(e.url,t.url)&&t.etag===e.etag))));return{...y,objects:D?{created:C,updated:w,deleted:b}:[...V,...C,...w],syncToken:null!==(c=null===(l=null===(d=null===(o=e[0])||void 0===o?void 0:o.raw)||void 0===d?void 0:d.multistatus)||void 0===l?void 0:l.syncToken)&&void 0!==c?c:y.syncToken}}if("basic"===w){const{isDirty:e,newCtag:t}=await U({collection:y,headers:v(m,A)}),r=null!==(u=y.objects)&&void 0!==u?u:[],a=null!==(p=await(null===(h=y.fetchObjects)||void 0===h?void 0:h.call(y,{collection:y,headers:v(m,A)})))&&void 0!==p?p:[],s=a.filter((e=>r.every((t=>!i(t.url,e.url))))),o=r.reduce(((e,t)=>{const r=a.find((e=>i(e.url,t.url)));return r&&r.etag&&r.etag!==t.etag?[...e,r]:e}),[]),n=r.filter((e=>a.every((t=>!i(t.url,e.url))))),d=r.filter((e=>a.some((t=>i(e.url,t.url)&&t.etag===e.etag))));if(e)return{...y,objects:D?{created:s,updated:o,deleted:n}:[...d,...s,...o],ctag:t}}return D?{...y,objects:{created:[],updated:[],deleted:[]}}:y};var R=Object.freeze({__proto__:null,collectionQuery:T,isCollectionDirty:U,makeCollection:$,smartCollectionSync:O,supportedReportSet:k,syncCollection:_});const L=t("tsdav:addressBook"),j=async e=>{const{url:t,props:r,filters:a,depth:o,headers:d,headersToExclude:l}=e;return T({url:t,body:{"addressbook-query":{_attributes:u([s.CARDDAV,s.DAV]),[`${n.DAV}:prop`]:r,filter:null!=a?a:{"prop-filter":{_attributes:{name:"FN"}}}}},defaultNamespace:n.CARDDAV,depth:o,headers:v(d,l)})},S=async e=>{const{url:t,props:r,objectUrls:a,depth:o,headers:d}=e;return T({url:t,body:{"addressbook-multiget":{_attributes:u([s.DAV,s.CARDDAV]),[`${n.DAV}:prop`]:r,[`${n.DAV}:href`]:a}},defaultNamespace:n.CARDDAV,depth:o,headers:d})},x=async e=>{const{account:t,headers:r,props:a,headersToExclude:s}=null!=e?e:{},o=["homeUrl","rootUrl"];if(!t||!b(t,o)){if(!t)throw new Error("no account for fetchAddressBooks");throw new Error(`account must have ${V(t,o)} before fetchAddressBooks`)}const d=await A({url:t.homeUrl,props:null!=a?a:{[`${n.DAV}:displayname`]:{},[`${n.CALENDAR_SERVER}:getctag`]:{},[`${n.DAV}:resourcetype`]:{},[`${n.DAV}:sync-token`]:{}},depth:"1",headers:v(r,s)});return Promise.all(d.filter((e=>{var t,r;return Object.keys(null!==(r=null===(t=e.props)||void 0===t?void 0:t.resourcetype)&&void 0!==r?r:{}).includes("addressbook")})).map((e=>{var r,a,s,o,n,d,l,c,i;const u=null!==(s=null===(a=null===(r=e.props)||void 0===r?void 0:r.displayname)||void 0===a?void 0:a._cdata)&&void 0!==s?s:null===(o=e.props)||void 0===o?void 0:o.displayname;return L(`Found address book named ${"string"==typeof u?u:""},\n             props: ${JSON.stringify(e.props)}`),{url:new URL(null!==(n=e.href)&&void 0!==n?n:"",null!==(d=t.rootUrl)&&void 0!==d?d:"").href,ctag:null===(l=e.props)||void 0===l?void 0:l.getctag,displayName:"string"==typeof u?u:"",resourcetype:Object.keys(null===(c=e.props)||void 0===c?void 0:c.resourcetype),syncToken:null===(i=e.props)||void 0===i?void 0:i.syncToken}})).map((async e=>({...e,reports:await k({collection:e,headers:r})}))))},N=async e=>{const{addressBook:t,headers:r,objectUrls:a,headersToExclude:s,urlFilter:o=(e=>e),useMultiGet:d=!0}=e;L(`Fetching vcards from ${null==t?void 0:t.url}`);const l=["url"];if(!t||!b(t,l)){if(!t)throw new Error("cannot fetchVCards for undefined addressBook");throw new Error(`addressBook must have ${V(t,l)} before fetchVCards`)}const c=(null!=a?a:(await j({url:t.url,props:{[`${n.DAV}:getetag`]:{}},depth:"1",headers:v(r,s)})).map((e=>{var t;return e.ok&&null!==(t=e.href)&&void 0!==t?t:""}))).map((e=>e.startsWith("http")||!e?e:new URL(e,t.url).href)).filter(o).map((e=>new URL(e).pathname));let i=[];return c.length>0&&(i=d?await S({url:t.url,props:{[`${n.DAV}:getetag`]:{},[`${n.CARDDAV}:address-data`]:{}},objectUrls:c,depth:"1",headers:v(r,s)}):await j({url:t.url,props:{[`${n.DAV}:getetag`]:{},[`${n.CARDDAV}:address-data`]:{}},depth:"1",headers:v(r,s)})),i.map((e=>{var r,a,s,o,n,d;return{url:new URL(null!==(r=e.href)&&void 0!==r?r:"",t.url).href,etag:null===(a=e.props)||void 0===a?void 0:a.getetag,data:null!==(n=null===(o=null===(s=e.props)||void 0===s?void 0:s.addressData)||void 0===o?void 0:o._cdata)&&void 0!==n?n:null===(d=e.props)||void 0===d?void 0:d.addressData}}))},H=async e=>{const{addressBook:t,vCardString:r,filename:a,headers:s,headersToExclude:o}=e;return g({url:new URL(a,t.url).href,data:r,headers:v({"content-type":"text/vcard; charset=utf-8","If-None-Match":"*",...s},o)})},P=async e=>{const{vCard:t,headers:r,headersToExclude:a}=e;return D({url:t.url,data:t.data,etag:t.etag,headers:v({"content-type":"text/vcard; charset=utf-8",...r},a)})},B=async e=>{const{vCard:t,headers:r,headersToExclude:a}=e;return C({url:t.url,etag:t.etag,headers:v(r,a)})};var I=Object.freeze({__proto__:null,addressBookMultiGet:S,addressBookQuery:j,createVCard:H,deleteVCard:B,fetchAddressBooks:x,fetchVCards:N,updateVCard:P});const M=t("tsdav:calendar"),F=async e=>{const{url:t,props:r,filters:a,timezone:o,depth:d,headers:l,headersToExclude:c}=e;return T({url:t,body:{"calendar-query":h({_attributes:u([s.CALDAV,s.CALENDAR_SERVER,s.CALDAV_APPLE,s.DAV]),[`${n.DAV}:prop`]:r,filter:a,timezone:o})},defaultNamespace:n.CALDAV,depth:d,headers:v(l,c)})},z=async e=>{const{url:t,props:r,objectUrls:a,filters:o,timezone:d,depth:l,headers:c,headersToExclude:i}=e;return T({url:t,body:{"calendar-multiget":{_attributes:u([s.DAV,s.CALDAV]),[`${n.DAV}:prop`]:r,[`${n.DAV}:href`]:a,...p("filter",o),timezone:d}},defaultNamespace:n.CALDAV,depth:l,headers:v(c,i)})},Z=async e=>{const{url:t,props:r,depth:a,headers:o,headersToExclude:d}=e;return m({url:t,init:{method:"MKCALENDAR",headers:v(h({depth:a,...o}),d),namespace:n.DAV,body:{[`${n.CALDAV}:mkcalendar`]:{_attributes:u([s.DAV,s.CALDAV,s.CALDAV_APPLE]),set:{prop:r}}}}})},G=async e=>{const{headers:t,account:r,props:a,projectedProps:s,headersToExclude:o}=null!=e?e:{},l=["homeUrl","rootUrl"];if(!r||!b(r,l)){if(!r)throw new Error("no account for fetchCalendars");throw new Error(`account must have ${V(r,l)} before fetchCalendars`)}const c=await A({url:r.homeUrl,props:null!=a?a:{[`${n.CALDAV}:calendar-description`]:{},[`${n.CALDAV}:calendar-timezone`]:{},[`${n.DAV}:displayname`]:{},[`${n.CALDAV_APPLE}:calendar-color`]:{},[`${n.CALENDAR_SERVER}:getctag`]:{},[`${n.DAV}:resourcetype`]:{},[`${n.CALDAV}:supported-calendar-component-set`]:{},[`${n.DAV}:sync-token`]:{}},depth:"1",headers:v(t,o)});return Promise.all(c.filter((e=>{var t,r;return Object.keys(null!==(r=null===(t=e.props)||void 0===t?void 0:t.resourcetype)&&void 0!==r?r:{}).includes("calendar")})).filter((e=>{var t,r,a,s;return((Array.isArray(null===(t=e.props)||void 0===t?void 0:t.supportedCalendarComponentSet.comp)?null===(r=e.props)||void 0===r?void 0:r.supportedCalendarComponentSet.comp.map((e=>e._attributes.name)):[null===(s=null===(a=e.props)||void 0===a?void 0:a.supportedCalendarComponentSet.comp)||void 0===s?void 0:s._attributes.name])||[]).some((e=>Object.values(d).includes(e)))})).map((e=>{var t,a,o,n,d,l,c,i,u,h,v,y,f,m,A,g;const D=null===(t=e.props)||void 0===t?void 0:t.calendarDescription,C=null===(a=e.props)||void 0===a?void 0:a.calendarTimezone;return{description:"string"==typeof D?D:"",timezone:"string"==typeof C?C:"",url:new URL(null!==(o=e.href)&&void 0!==o?o:"",null!==(n=r.rootUrl)&&void 0!==n?n:"").href,ctag:null===(d=e.props)||void 0===d?void 0:d.getctag,calendarColor:null===(l=e.props)||void 0===l?void 0:l.calendarColor,displayName:null!==(i=null===(c=e.props)||void 0===c?void 0:c.displayname._cdata)&&void 0!==i?i:null===(u=e.props)||void 0===u?void 0:u.displayname,components:Array.isArray(null===(h=e.props)||void 0===h?void 0:h.supportedCalendarComponentSet.comp)?null===(v=e.props)||void 0===v?void 0:v.supportedCalendarComponentSet.comp.map((e=>e._attributes.name)):[null===(f=null===(y=e.props)||void 0===y?void 0:y.supportedCalendarComponentSet.comp)||void 0===f?void 0:f._attributes.name],resourcetype:Object.keys(null===(m=e.props)||void 0===m?void 0:m.resourcetype),syncToken:null===(A=e.props)||void 0===A?void 0:A.syncToken,...p("projectedProps",Object.fromEntries(Object.entries(null!==(g=e.props)&&void 0!==g?g:{}).filter((([e])=>null==s?void 0:s[e]))))}})).map((async e=>({...e,reports:await k({collection:e,headers:v(t,o)})}))))},Q=async e=>{const{calendar:t,objectUrls:r,filters:a,timeRange:s,headers:o,expand:d,urlFilter:l=(e=>Boolean(null==e?void 0:e.includes(".ics"))),useMultiGet:c=!0,headersToExclude:i}=e;if(s){const e=/^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z)?)?)?)?$/i,t=/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(([+-]\d\d:\d\d)|Z)?$/i;if(!(e.test(s.start)&&e.test(s.end)||t.test(s.start)&&t.test(s.end)))throw new Error("invalid timeRange format, not in ISO8601")}M(`Fetching calendar objects from ${null==t?void 0:t.url}`);const u=["url"];if(!t||!b(t,u)){if(!t)throw new Error("cannot fetchCalendarObjects for undefined calendar");throw new Error(`calendar must have ${V(t,u)} before fetchCalendarObjects`)}const h=null!=a?a:[{"comp-filter":{_attributes:{name:"VCALENDAR"},"comp-filter":{_attributes:{name:"VEVENT"},...s?{"time-range":{_attributes:{start:`${new Date(s.start).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`,end:`${new Date(s.end).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`}}}:{}}}}],p=(null!=r?r:(await F({url:t.url,props:{[`${n.DAV}:getetag`]:{...d&&s?{[`${n.CALDAV}:expand`]:{_attributes:{start:`${new Date(s.start).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`,end:`${new Date(s.end).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`}}}:{}}},filters:h,depth:"1",headers:v(o,i)})).map((e=>{var t;return null!==(t=e.href)&&void 0!==t?t:""}))).map((e=>e.startsWith("http")||!e?e:new URL(e,t.url).href)).filter(l).map((e=>new URL(e).pathname));let y=[];return p.length>0&&(y=!c||d?await F({url:t.url,props:{[`${n.DAV}:getetag`]:{},[`${n.CALDAV}:calendar-data`]:{...d&&s?{[`${n.CALDAV}:expand`]:{_attributes:{start:`${new Date(s.start).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`,end:`${new Date(s.end).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`}}}:{}}},filters:h,depth:"1",headers:v(o,i)}):await z({url:t.url,props:{[`${n.DAV}:getetag`]:{},[`${n.CALDAV}:calendar-data`]:{...d&&s?{[`${n.CALDAV}:expand`]:{_attributes:{start:`${new Date(s.start).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`,end:`${new Date(s.end).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`}}}:{}}},objectUrls:p,depth:"1",headers:v(o,i)})),y.map((e=>{var r,a,s,o,n,d;return{url:new URL(null!==(r=e.href)&&void 0!==r?r:"",t.url).href,etag:`${null===(a=e.props)||void 0===a?void 0:a.getetag}`,data:null!==(n=null===(o=null===(s=e.props)||void 0===s?void 0:s.calendarData)||void 0===o?void 0:o._cdata)&&void 0!==n?n:null===(d=e.props)||void 0===d?void 0:d.calendarData}}))},q=async e=>{const{calendar:t,iCalString:r,filename:a,headers:s,headersToExclude:o}=e;return g({url:new URL(a,t.url).href,data:r,headers:v({"content-type":"text/calendar; charset=utf-8","If-None-Match":"*",...s},o)})},J=async e=>{const{calendarObject:t,headers:r,headersToExclude:a}=e;return D({url:t.url,data:t.data,etag:t.etag,headers:v({"content-type":"text/calendar; charset=utf-8",...r},a)})},K=async e=>{const{calendarObject:t,headers:r,headersToExclude:a}=e;return C({url:t.url,etag:t.etag,headers:v(r,a)})},W=async e=>{var t;const{oldCalendars:r,account:a,detailedResult:s,headers:o,headersToExclude:n}=e;if(!a)throw new Error("Must have account before syncCalendars");const d=null!==(t=null!=r?r:a.calendars)&&void 0!==t?t:[],l=await G({account:a,headers:v(o,n)}),c=l.filter((e=>d.every((t=>!i(t.url,e.url)))));M(`new calendars: ${c.map((e=>e.displayName))}`);const u=d.reduce(((e,t)=>{const r=l.find((e=>i(e.url,t.url)));return r&&(r.syncToken&&r.syncToken!==t.syncToken||r.ctag&&r.ctag!==t.ctag)?[...e,r]:e}),[]);M(`updated calendars: ${u.map((e=>e.displayName))}`);const h=await Promise.all(u.map((async e=>await O({collection:{...e,objectMultiGet:z},method:"webdav",headers:v(o,n),account:a})))),p=d.filter((e=>l.every((t=>!i(t.url,e.url)))));M(`deleted calendars: ${p.map((e=>e.displayName))}`);const y=d.filter((e=>l.some((t=>i(t.url,e.url)&&(t.syncToken&&t.syncToken!==e.syncToken||t.ctag&&t.ctag!==e.ctag)))));return s?{created:c,updated:u,deleted:p}:[...y,...c,...h]},Y=async e=>{const{url:t,timeRange:r,depth:a,headers:o,headersToExclude:d}=e;if(!r)throw new Error("timeRange is required");{const e=/^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z)?)?)?)?$/i,t=/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(([+-]\d\d:\d\d)|Z)?$/i;if(!(e.test(r.start)&&e.test(r.end)||t.test(r.start)&&t.test(r.end)))throw new Error("invalid timeRange format, not in ISO8601")}return(await T({url:t,body:{"free-busy-query":h({_attributes:u([s.CALDAV]),[`${n.CALDAV}:time-range`]:{_attributes:{start:`${new Date(r.start).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`,end:`${new Date(r.end).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`}}})},defaultNamespace:n.CALDAV,depth:a,headers:v(o,d)}))[0]};var X=Object.freeze({__proto__:null,calendarMultiGet:z,calendarQuery:F,createCalendarObject:q,deleteCalendarObject:K,fetchCalendarObjects:Q,fetchCalendars:G,freeBusyQuery:Y,makeCalendar:Z,syncCalendars:W,updateCalendarObject:J});const ee=t("tsdav:account"),te=async t=>{var r,a;ee("Service discovery...");const{account:s,headers:o,headersToExclude:n}=t,d=new URL(s.serverUrl),l=new URL(`/.well-known/${s.accountType}`,d);l.protocol=null!==(r=d.protocol)&&void 0!==r?r:"http";try{const t=await e(l.href,{headers:v(o,n),method:"PROPFIND",redirect:"manual"});if(t.status>=300&&t.status<400){const e=t.headers.get("Location");if("string"==typeof e&&e.length){ee(`Service discovery redirected to ${e}`);const t=new URL(e,d);return t.hostname===l.hostname&&l.port&&!t.port&&(t.port=l.port),t.protocol=null!==(a=d.protocol)&&void 0!==a?a:"http",t.href}}}catch(e){ee(`Service discovery failed: ${e.stack}`)}return d.href},re=async e=>{var t,r,a,s,o;const{account:d,headers:l,headersToExclude:c}=e,i=["rootUrl"];if(!b(d,i))throw new Error(`account must have ${V(d,i)} before fetchPrincipalUrl`);ee(`Fetching principal url from path ${d.rootUrl}`);const[u]=await A({url:d.rootUrl,props:{[`${n.DAV}:current-user-principal`]:{}},depth:"0",headers:v(l,c)});if(!u.ok&&(ee(`Fetch principal url failed: ${u.statusText}`),401===u.status))throw new Error("Invalid credentials");return ee(`Fetched principal url ${null===(r=null===(t=u.props)||void 0===t?void 0:t.currentUserPrincipal)||void 0===r?void 0:r.href}`),new URL(null!==(o=null===(s=null===(a=u.props)||void 0===a?void 0:a.currentUserPrincipal)||void 0===s?void 0:s.href)&&void 0!==o?o:"",d.rootUrl).href},ae=async e=>{var t,r;const{account:a,headers:s,headersToExclude:o}=e,d=["principalUrl","rootUrl"];if(!b(a,d))throw new Error(`account must have ${V(a,d)} before fetchHomeUrl`);ee(`Fetch home url from ${a.principalUrl}`);const l=(await A({url:a.principalUrl,props:"caldav"===a.accountType?{[`${n.CALDAV}:calendar-home-set`]:{}}:{[`${n.CARDDAV}:addressbook-home-set`]:{}},depth:"0",headers:v(s,o)})).find((e=>i(a.principalUrl,e.href)));if(!l||!l.ok)throw new Error("cannot find homeUrl");const c=new URL("caldav"===a.accountType?null===(t=null==l?void 0:l.props)||void 0===t?void 0:t.calendarHomeSet.href:null===(r=null==l?void 0:l.props)||void 0===r?void 0:r.addressbookHomeSet.href,a.rootUrl).href;return ee(`Fetched home url ${c}`),c},se=async e=>{const{account:t,headers:r,loadCollections:a=!1,loadObjects:s=!1,headersToExclude:o}=e,n={...t};return n.rootUrl=n.rootUrl||await te({account:t,headers:v(r,o)}),n.principalUrl=n.principalUrl||await re({account:n,headers:v(r,o)}),n.homeUrl=n.homeUrl||await ae({account:n,headers:v(r,o)}),(a||s)&&("caldav"===t.accountType?n.calendars=await G({headers:v(r,o),account:n}):"carddav"===t.accountType&&(n.addressBooks=await x({headers:v(r,o),account:n}))),s&&("caldav"===t.accountType&&n.calendars?n.calendars=await Promise.all(n.calendars.map((async e=>({...e,objects:await Q({calendar:e,headers:v(r,o)})})))):"carddav"===t.accountType&&n.addressBooks&&(n.addressBooks=await Promise.all(n.addressBooks.map((async e=>({...e,objects:await N({addressBook:e,headers:v(r,o)})})))))),n};var oe=Object.freeze({__proto__:null,createAccount:se,fetchHomeUrl:ae,fetchPrincipalUrl:re,serviceDiscovery:te});const ne=t("tsdav:authHelper"),de=(e,t)=>(...r)=>e({...t,...r[0]}),le=e=>(ne(`Basic auth token generated: ${a(`${e.username}:${e.password}`)}`),{authorization:`Basic ${a(`${e.username}:${e.password}`)}`}),ce=async t=>{const r=["authorizationCode","redirectUrl","clientId","clientSecret","tokenUrl"];if(!b(t,r))throw new Error(`Oauth credentials missing: ${V(t,r)}`);const a=new URLSearchParams({grant_type:"authorization_code",code:t.authorizationCode,redirect_uri:t.redirectUrl,client_id:t.clientId,client_secret:t.clientSecret});ne(t.tokenUrl),ne(a.toString());const s=await e(t.tokenUrl,{method:"POST",body:a.toString(),headers:{"content-length":`${a.toString().length}`,"content-type":"application/x-www-form-urlencoded"}});if(s.ok){return await s.json()}return ne(`Fetch Oauth tokens failed: ${await s.text()}`),{}},ie=async t=>{const r=["refreshToken","clientId","clientSecret","tokenUrl"];if(!b(t,r))throw new Error(`Oauth credentials missing: ${V(t,r)}`);const a=new URLSearchParams({client_id:t.clientId,client_secret:t.clientSecret,refresh_token:t.refreshToken,grant_type:"refresh_token"}),s=await e(t.tokenUrl,{method:"POST",body:a.toString(),headers:{"Content-Type":"application/x-www-form-urlencoded"}});if(s.ok){return await s.json()}return ne(`Refresh access token failed: ${await s.text()}`),{}},ue=async e=>{var t;ne("Fetching oauth headers");let r={};return e.refreshToken?(e.refreshToken&&!e.accessToken||Date.now()>(null!==(t=e.expiration)&&void 0!==t?t:0))&&(r=await ie(e)):r=await ce(e),ne(`Oauth tokens fetched: ${r.access_token}`),{tokens:r,headers:{authorization:`Bearer ${r.access_token}`}}};var he=Object.freeze({__proto__:null,defaultParam:de,fetchOauthTokens:ce,getBasicAuthHeaders:le,getOauthHeaders:ue,refreshAccessToken:ie});const pe=async e=>{var t;const{serverUrl:r,credentials:a,authMethod:s,defaultAccountType:o,authFunction:n,rootUrl:d,principalUrl:l,homeUrl:c}=e;let i={};switch(s){case"Basic":i=le(a);break;case"Oauth":i=(await ue(a)).headers;break;case"Digest":i={Authorization:`Digest ${a.digestString}`};break;case"Custom":i=null!==(t=await(null==n?void 0:n(a)))&&void 0!==t?t:{};break;default:throw new Error("Invalid auth method")}const u=o?await se({account:{serverUrl:r,credentials:a,accountType:o,rootUrl:d,principalUrl:l,homeUrl:c},headers:i}):void 0,h=de(g,{url:r,headers:i}),p=de(D,{headers:i,url:r}),v=de(C,{headers:i,url:r}),y=de(A,{headers:i}),f=de(T,{headers:i}),w=de($,{headers:i}),b=de(_,{headers:i}),V=de(k,{headers:i}),E=de(U,{headers:i}),R=de(O,{headers:i,account:u}),L=de(F,{headers:i}),I=de(z,{headers:i}),M=de(Z,{headers:i}),Y=de(G,{headers:i,account:u}),X=de(Q,{headers:i}),ee=de(q,{headers:i}),te=de(J,{headers:i}),re=de(K,{headers:i}),ae=de(W,{account:u,headers:i}),oe=de(j,{headers:i}),ne=de(S,{headers:i});return{davRequest:async e=>{const{init:t,...r}=e,{headers:a,...s}=t;return m({...r,init:{...s,headers:{...i,...a}}})},propfind:y,createAccount:async e=>{const{account:t,headers:s,loadCollections:o,loadObjects:n}=e;return se({account:{serverUrl:r,credentials:a,...t},headers:{...i,...s},loadCollections:o,loadObjects:n})},createObject:h,updateObject:p,deleteObject:v,calendarQuery:L,addressBookQuery:oe,collectionQuery:f,makeCollection:w,calendarMultiGet:I,makeCalendar:M,syncCollection:b,supportedReportSet:V,isCollectionDirty:E,smartCollectionSync:R,fetchCalendars:Y,fetchCalendarObjects:X,createCalendarObject:ee,updateCalendarObject:te,deleteCalendarObject:re,syncCalendars:ae,fetchAddressBooks:de(x,{account:u,headers:i}),addressBookMultiGet:ne,fetchVCards:de(N,{headers:i}),createVCard:de(H,{headers:i}),updateVCard:de(P,{headers:i}),deleteVCard:de(B,{headers:i}),defaultAccount:u}};class ve{constructor(e){var t,r;this.serverUrl=e.serverUrl,this.credentials=e.credentials,this.authMethod=null!==(t=e.authMethod)&&void 0!==t?t:"Basic",this.accountType=null!==(r=e.defaultAccountType)&&void 0!==r?r:"caldav"}async login(){var e;switch(this.authMethod){case"Basic":this.authHeaders=le(this.credentials);break;case"Oauth":this.authHeaders=(await ue(this.credentials)).headers;break;case"Digest":this.authHeaders={Authorization:`Digest ${this.credentials.digestString}`};break;case"Custom":this.authHeaders=await(null===(e=this.authFunction)||void 0===e?void 0:e.call(this,this.credentials));break;default:throw new Error("Invalid auth method")}this.account=this.accountType?await se({account:{serverUrl:this.serverUrl,credentials:this.credentials,accountType:this.accountType},headers:this.authHeaders}):void 0}async davRequest(e){const{init:t,...r}=e,{headers:a,...s}=t;return m({...r,init:{...s,headers:{...this.authHeaders,...a}}})}async createObject(...e){return de(g,{url:this.serverUrl,headers:this.authHeaders})(e[0])}async updateObject(...e){return de(D,{headers:this.authHeaders,url:this.serverUrl})(e[0])}async deleteObject(...e){return de(C,{headers:this.authHeaders,url:this.serverUrl})(e[0])}async propfind(...e){return de(A,{headers:this.authHeaders})(e[0])}async createAccount(e){const{account:t,headers:r,loadCollections:a,loadObjects:s}=e;return se({account:{serverUrl:this.serverUrl,credentials:this.credentials,...t},headers:{...this.authHeaders,...r},loadCollections:a,loadObjects:s})}async collectionQuery(...e){return de(T,{headers:this.authHeaders})(e[0])}async makeCollection(...e){return de($,{headers:this.authHeaders})(e[0])}async syncCollection(...e){return de(_,{headers:this.authHeaders})(e[0])}async supportedReportSet(...e){return de(k,{headers:this.authHeaders})(e[0])}async isCollectionDirty(...e){return de(U,{headers:this.authHeaders})(e[0])}async smartCollectionSync(...e){return de(O,{headers:this.authHeaders,account:this.account})(e[0])}async calendarQuery(...e){return de(F,{headers:this.authHeaders})(e[0])}async makeCalendar(...e){return de(Z,{headers:this.authHeaders})(e[0])}async calendarMultiGet(...e){return de(z,{headers:this.authHeaders})(e[0])}async fetchCalendars(...e){return de(G,{headers:this.authHeaders,account:this.account})(null==e?void 0:e[0])}async fetchCalendarObjects(...e){return de(Q,{headers:this.authHeaders})(e[0])}async createCalendarObject(...e){return de(q,{headers:this.authHeaders})(e[0])}async updateCalendarObject(...e){return de(J,{headers:this.authHeaders})(e[0])}async deleteCalendarObject(...e){return de(K,{headers:this.authHeaders})(e[0])}async syncCalendars(...e){return de(W,{headers:this.authHeaders,account:this.account})(e[0])}async addressBookQuery(...e){return de(j,{headers:this.authHeaders})(e[0])}async addressBookMultiGet(...e){return de(S,{headers:this.authHeaders})(e[0])}async fetchAddressBooks(...e){return de(x,{headers:this.authHeaders,account:this.account})(null==e?void 0:e[0])}async fetchVCards(...e){return de(N,{headers:this.authHeaders})(e[0])}async createVCard(...e){return de(H,{headers:this.authHeaders})(e[0])}async updateVCard(...e){return de(P,{headers:this.authHeaders})(e[0])}async deleteVCard(...e){return de(B,{headers:this.authHeaders})(e[0])}}var ye={DAVNamespace:s,DAVNamespaceShort:n,DAVAttributeMap:o,...Object.freeze({__proto__:null,DAVClient:ve,createDAVClient:pe}),...w,...R,...oe,...I,...X,...he,...y};export{o as DAVAttributeMap,ve as DAVClient,s as DAVNamespace,n as DAVNamespaceShort,j as addressBookQuery,z as calendarMultiGet,F as calendarQuery,h as cleanupFalsy,T as collectionQuery,se as createAccount,q as createCalendarObject,pe as createDAVClient,g as createObject,H as createVCard,m as davRequest,ye as default,K as deleteCalendarObject,C as deleteObject,B as deleteVCard,x as fetchAddressBooks,Q as fetchCalendarObjects,G as fetchCalendars,ce as fetchOauthTokens,N as fetchVCards,Y as freeBusyQuery,le as getBasicAuthHeaders,u as getDAVAttribute,ue as getOauthHeaders,U as isCollectionDirty,Z as makeCalendar,A as propfind,ie as refreshAccessToken,O as smartCollectionSync,k as supportedReportSet,W as syncCalendars,_ as syncCollection,J as updateCalendarObject,D as updateObject,P as updateVCard,i as urlContains,c as urlEquals};
